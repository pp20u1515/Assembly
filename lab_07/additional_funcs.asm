segment .text ; указываю, в какую секцию выходного файла будет ассемблирован код

global my_strncpy

my_strncpy:
     
     push ebp
     mov ebp, esp

     mov edi, [ebp + 8] ; загружаем первый аргумент функции в регистр edi
     mov esi, [ebp + 12] ; загружаем второй аргумент функции в регистр esi
     mov ecx, [ebp + 16] ; загружаем третий аргумент функции в регистр ecx
     inc ecx ; увеличиваем значение ecx на единицу, чтобы скопировать еще 
             ; один символ, который обычно является символом конца строки

     push ebx ; сохраняем текущее значение регистра ebx на вершине стека, для его дальнейшего использования

     mov ebx, edi ; копируем адрес строки, куда копируем в регистр ebx

     cmp edi, esi ; сравниваем адреса строк, куда копируем и от куда копируем
     jg copy_from_end ; если адрес исходной строки (esi) меньше адреса строки, куда копируем(edi)
                          ; то переходим к метке copy_from_end для копирования символов с конца
                          ; строки. Если это не так, то продолжаем копирование символов с начала строки

    copy_at_first:

        rep movsb
        jmp finish

    copy_from_end:
        ;устанавливаем рeгистры на последные символы строк
        add edi, ecx
        add esi, ecx

        dec edi
        dec esi

        std ; устанавливает флаг направления, который заставляет инструкцию rep movsb
            ; копировать байти в обратном порядке начиная с конца строк и заканчивая их началом

        rep movsb ; инструкция копирования блока памяти

        cld ; сбрасывает флаг направления и восстанавливает его в значение по умолчанию,
            ; чтобы последующие операции копирования происходили в прямом порядке не 
            ; нарушая работу других функции, которые могут использовать инструкцию rep movsb 

    finish:

        mov eax, ebx

        pop ebx
        pop ebp

        ret
